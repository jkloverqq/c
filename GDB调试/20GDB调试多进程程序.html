<!DOCTYPE html>
<!-- saved from url=(0041)http://c.biancheng.net/view/vip_8517.html -->
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" async="" charset="utf-8" src="./20GDB调试多进程程序_files/core.php"></script>

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<!-- 启用Chromium高速渲染模式 -->
<meta name="renderer" content="webkit">
<meta name="force-rendering" content="webkit">
<!-- 禁止百度转码 -->
<meta name="applicable-device" content="pc,mobile">
<meta name="MobileOptimized" content="width">
<meta name="HandheldFriendly" content="true">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
<!-- 禁止识别电话号码 -->
<meta name="format-detection" content="telephone=no">

<link rel="shortcut icon" href="http://c.biancheng.net/favicon.ico?v=1.6.72">
<link href="./20GDB调试多进程程序_files/common.css" rel="stylesheet">
<title>GDB调试多进程程序</title>
<meta name="description" content="GDB调试器不只可以调试多线程程序，还可以调试多进程程序。 对于 C 和 C++ 程序而言，多进程的实现往往借助的是 unistd.h 头文件中的 fork() 函数或者 vfork() 函数。举个例子： #include std">
</head>
<body>
<div id="topbar" class="clearfix">
	<ul id="product-type" class="left">
		<li>
			<a href="http://c.biancheng.net/"><span class="iconfont iconfont-home"></span>首页</a>
		</li>
		<li class="active">
			<a href="http://c.biancheng.net/sitemap/" rel="nofollow"><span class="iconfont iconfont-book"></span>教程</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/vip/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-vip"></span>VIP会员</a>
		</li>
		<li>
			<a href="http://vip.biancheng.net/p/q2a/show.php" rel="nofollow" target="_blank"><span class="iconfont iconfont-q2a"></span>一对一答疑</a>
		</li>
		<li>
			<a href="http://fudao.biancheng.net/" rel="nofollow" target="_blank"><span class="iconfont iconfont-fudao"></span>辅导班</a>
		</li>
	</ul>
</div>
<div id="header" class="clearfix">
	<a id="logo" class="left" href="http://c.biancheng.net/">
		<img height="26" src="./20GDB调试多进程程序_files/logo.png" alt="C语言中文网">
	</a>
	<ul id="nav-main" class="hover-none left clearfix">
		<li class="wap-yes"><a href="http://c.biancheng.net/">首页</a></li>
		<li><a href="http://c.biancheng.net/c/">C语言教程</a></li>
		<li><a href="http://c.biancheng.net/cplus/">C++教程</a></li>
		<li><a href="http://c.biancheng.net/python/">Python教程</a></li>
		<li><a href="http://c.biancheng.net/java/">Java教程</a></li>
		<li><a href="http://c.biancheng.net/linux_tutorial/">Linux入门</a></li>
		<li><a href="http://c.biancheng.net/sitemap/" title="网站地图">更多&gt;&gt;</a></li>
	</ul>
	<span id="sidebar-toggle" class="toggle-btn" toggle-target="#sidebar">目录 <span class="glyphicon"></span></span>

	<a href="http://vip.biancheng.net/?from=topbar" class="user-info glyphicon glyphicon-user hover-none" target="_blank" rel="nofollow" title="用户中心"></a>
</div>
<div id="main" class="clearfix">
	<div id="sidebar" class="toggle-target">
	<div id="contents">
		<dt><span class="glyphicon glyphicon-option-vertical" aria-hidden="true"></span><a href="http://c.biancheng.net/gdb/">GDB</a></dt>
		<dd>
        	<span class="channel-num">1</span>
        	<a href="http://c.biancheng.net/view/8123.html">GDB是什么？</a>
        </dd>
<dd>
        	<span class="channel-num">2</span>
        	<a href="http://c.biancheng.net/view/8130.html">GDB下载和安装教程</a>
        </dd>
<dd>
        	<span class="channel-num">3</span>
        	<a href="http://c.biancheng.net/view/vip_8511.html">如何在Windows平台上安装GDB调试器？</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd>
        	<span class="channel-num">4</span>
        	<a href="http://c.biancheng.net/view/vip_8512.html">Sublime Text配置GDB调试环境</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd>
        	<span class="channel-num">5</span>
        	<a href="http://c.biancheng.net/view/8153.html">GDB调试C/C++程序的整个过程</a>
        </dd>
<dd>
        	<span class="channel-num">6</span>
        	<a href="http://c.biancheng.net/view/vip_8520.html">调用GDB调试器的4种方式</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd>
        	<span class="channel-num">7</span>
        	<a href="http://c.biancheng.net/view/8174.html">gdb run（r）命令：启动程序</a>
        </dd>
<dd>
        	<span class="channel-num">8</span>
        	<a href="http://c.biancheng.net/view/8189.html">GDB break（b）：设置断点</a>
        </dd>
<dd>
        	<span class="channel-num">9</span>
        	<a href="http://c.biancheng.net/view/8191.html">如何实时监控变量值的变化情况？</a>
        </dd>
<dd>
        	<span class="channel-num">10</span>
        	<a href="http://c.biancheng.net/view/8199.html">GDB catch命令：建立捕捉断点</a>
        </dd>
<dd>
        	<span class="channel-num">11</span>
        	<a href="http://c.biancheng.net/view/8255.html">GDB条件断点（condition命令）详解</a>
        </dd>
<dd>
        	<span class="channel-num">12</span>
        	<a href="http://c.biancheng.net/view/8232.html">GDB单步调试程序</a>
        </dd>
<dd>
        	<span class="channel-num">13</span>
        	<a href="http://c.biancheng.net/view/vip_8519.html">如何使用GDB进行断点调试？</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd>
        	<span class="channel-num">14</span>
        	<a href="http://c.biancheng.net/view/8238.html">GDB print和display命令：查看变量的值</a>
        </dd>
<dd>
        	<span class="channel-num">15</span>
        	<a href="http://c.biancheng.net/view/vip_8513.html">GDB print命令更高级的用法！</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd>
        	<span class="channel-num">16</span>
        	<a href="http://c.biancheng.net/view/8219.html">GDB禁用和删除断点</a>
        </dd>
<dd>
        	<span class="channel-num">17</span>
        	<a href="http://c.biancheng.net/view/vip_8514.html">如何用GDB调试多线程程序？</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd>
        	<span class="channel-num">18</span>
        	<a href="http://c.biancheng.net/view/vip_8515.html">GDB non-stop模式详解</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd>
        	<span class="channel-num">19</span>
        	<a href="http://c.biancheng.net/view/vip_8516.html">GDB如何在后台执行调试命令？</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd class="active">
        	<span class="channel-num">20</span>
        	<a href="http://c.biancheng.net/view/vip_8517.html">GDB调试多进程程序</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd>
        	<span class="channel-num">21</span>
        	<a href="http://c.biancheng.net/view/vip_8518.html">GDB如何进行反向调试？</a><span class="glyphicon glyphicon-usd"></span>
        </dd>
<dd>
        	<span class="channel-num">22</span>
        	<a href="http://c.biancheng.net/view/8291.html">GDB handle命令：信号处理</a>
        </dd>
<dd>
        	<span class="channel-num">23</span>
        	<a href="http://c.biancheng.net/view/8282.html">GDB frame和backtrace命令：查看栈信息</a>
        </dd>
<dd>
        	<span class="channel-num">24</span>
        	<a href="http://c.biancheng.net/view/7466.html">GDB编辑和搜索源码</a>
        </dd>
<dd>
        	<span class="channel-num">25</span>
        	<a href="http://c.biancheng.net/view/8293.html">GDB help命令：查看目标命令的具体用法</a>
        </dd>

	</div>
</div>
	<div id="article-wrap">
		<div id="article">
			<div class="arc-info">
	<span class="position"><span class="glyphicon glyphicon-map-marker"></span> <a href="http://c.biancheng.net/">首页</a> &gt; <a href="http://c.biancheng.net/gdb/">GDB</a></span>
	<span class="read-num">阅读：1,533</span>
</div>

<div id="ad-position-bottom"></div>
			<h1>GDB调试多进程程序</h1>
			<div class="pre-next-page clearfix">
                    <span class="pre left"><span class="icon">&lt;</span> <span class="text-brief text-brief-pre">上一页</span><a href="http://c.biancheng.net/view/vip_8516.html">GDB如何在后台执行调试命令？</a></span>
                    <span class="next right"><a href="http://c.biancheng.net/view/vip_8518.html">GDB如何进行反向调试？</a><span class="text-brief text-brief-next">下一页</span> <span class="icon">&gt;</span></span>
                </div>
			<div id="ad-arc-top"><p class="pic"></p><p class="text" adid="default"><a href="http://fudao.biancheng.net/" rel="nofollow" target="_blank" style="color:#D33428;">C语言中文网推出辅导班啦，包括<span style="color: #008000;">「C语言辅导班、C++辅导班、算法/数据结构辅导班」</span>，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践 + 永久学习。QQ在线，随时响应！</a></p></div>
			<div id="arc-body">GDB调试器不只可以调试多线程程序，还可以调试多进程程序。<br>
<br>
对于 C 和 C++ 程序而言，多进程的实现往往借助的是<code>&lt;unistd.h&gt;</code>头文件中的 fork() 函数或者 vfork() 函数。举个例子：
<div class="snippet-container" style="undefined;"><div class="sh_bright snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display: none;"><pre><a class="snippet-copy sh_url" href="http://c.biancheng.net/view/vip_8517.html#" style="display: none;">复制</a><a class="snippet-text sh_url" href="http://c.biancheng.net/view/vip_8517.html#">纯文本</a><a class="snippet-window sh_url" href="http://c.biancheng.net/view/vip_8517.html#">复制</a></pre></div><pre class="cpp sh_cpp snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_preproc">#include</span> <span class="sh_string">&lt;stdio.h&gt;</span></li><li><span class="sh_preproc">#include</span> <span class="sh_string">&lt;unistd.h&gt;</span></li><li><span style="display:none;">&nbsp;</span></li><li><span class="sh_type">int</span> <span class="sh_function">main</span><span class="sh_symbol">()</span></li><li><span class="sh_cbracket">{</span></li><li>    <span class="sh_usertype">pid_t</span><span class="sh_normal"> </span>pid <span class="sh_symbol">=</span> <span class="sh_function">fork</span><span class="sh_symbol">();</span></li><li>    <span class="sh_keyword">if</span><span class="sh_symbol">(</span>pid <span class="sh_symbol">==</span> <span class="sh_number">0</span><span class="sh_symbol">)</span></li><li>    <span class="sh_cbracket">{</span></li><li>        <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"this is child,pid = %d</span><span class="sh_specialchar">\n</span><span class="sh_string">"</span><span class="sh_symbol">,</span><span class="sh_function">getpid</span><span class="sh_symbol">());</span></li><li>    <span class="sh_cbracket">}</span></li><li>    <span class="sh_keyword">else</span></li><li>    <span class="sh_cbracket">{</span></li><li>        <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"this is parent,pid = %d</span><span class="sh_specialchar">\n</span><span class="sh_string">"</span><span class="sh_symbol">,</span><span class="sh_function">getpid</span><span class="sh_symbol">());</span></li><li>    <span class="sh_cbracket">}</span></li><li>    <span class="sh_keyword">return</span> <span class="sh_number">0</span><span class="sh_symbol">;</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    pid_t pid = fork();
    if(pid == 0)
    {
        printf("this is child,pid = %d\n",getpid());
    }
    else
    {
        printf("this is parent,pid = %d\n",getpid());
    }
    return 0;
}</pre></div></div>
程序的存储路径为<code>~/demo/myfork.c</code>。可以看到，程序中包含 2 个进程，分别为父进程（又称主进程）和使用 fork() 函数分离出的子进程。<br>
<br>
事实上在多数 Linux 发行版系统中，GDB 并没有对多进程程序提供友好的调试功能。无论程序中调用了多少次 fork() 函数（或者 vfork() 函数），从父进程中分离出多少个子进程，GDB 默认只调试父进程，而不调试子进程。<br>
<br>
那么问题就出现了，如何使用 GDB 调试多进程程序中的子进程呢？
<h2>
	GDB attach命令调试进程</h2>
首先，无论父进程还是子进程，都可以借助 attach 命令启动 GDB 调试它。attach 命令用于调试正在运行的进程，要知道对于每个运行的进程，操作系统都会为其配备一个独一无二的 ID 号。在得知目标子进程 ID 号的前提下，就可以借助 attach 命令来启动 GDB 对其进行调试。<br>
<br>
这里还需要解决一个问题，很多场景中子进程的执行时间都是一瞬而逝的，这意味着，我们可能还未查到它的进程 ID 号，该进程就已经执行完了，何谈借助 attach 命令对其调试呢？对于 C、C++ 多进程程序，解决该问题最简单直接的方法是，在目标进程所执行代码的开头位置，添加一段延时执行的代码。<br>
<br>
例如，将上面程序中<code>if(pid==0)</code>判断语句整体做如下修改：
<div class="snippet-container" style="undefined;"><div class="sh_bright snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre><a class="snippet-copy sh_url" href="http://c.biancheng.net/view/vip_8517.html#" style="display: none;">复制</a><a class="snippet-text sh_url" href="http://c.biancheng.net/view/vip_8517.html#">纯文本</a><a class="snippet-window sh_url" href="http://c.biancheng.net/view/vip_8517.html#">复制</a></pre></div><pre class="cpp sh_cpp snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">if</span><span class="sh_symbol">(</span>pid <span class="sh_symbol">==</span> <span class="sh_number">0</span><span class="sh_symbol">)</span></li><li><span class="sh_cbracket">{</span></li><li>    <span class="sh_type">int</span> num <span class="sh_symbol">=</span><span class="sh_number">10</span><span class="sh_symbol">;</span></li><li>    <span class="sh_keyword">while</span><span class="sh_symbol">(</span>num<span class="sh_symbol">==</span><span class="sh_number">10</span><span class="sh_symbol">)</span><span class="sh_cbracket">{</span></li><li>        <span class="sh_function">sleep</span><span class="sh_symbol">(</span><span class="sh_number">10</span><span class="sh_symbol">);</span></li><li>    <span class="sh_cbracket">}</span></li><li>    <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"this is child,pid = %d</span><span class="sh_specialchar">\n</span><span class="sh_string">"</span><span class="sh_symbol">,</span><span class="sh_function">getpid</span><span class="sh_symbol">());</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">if(pid == 0)
{
    int num =10;
    while(num==10){
        sleep(10);
    }
    printf("this is child,pid = %d\n",getpid());
}</pre></div></div>
可以看到，通过添加第 3~6 行代码，该进程执行时会直接进入死循环。这样做的好处有 2 个，其一是帮助 attach 命令成功捕捉到要调试的进程；其二是使用 GDB 调试该进程时，进程中真正的代码部分尚未得到执行，使得我们可以从头开始对进程中的代码进行调试。
<blockquote>
	<p>
		有读者可能会问，进程都已经进行死循环了，后续代码还可以进行调试吗？当然可以，以上面示例中给出的死循环，我们只需用 print 命令临时修改 num 变量的值，即可使程序跳出循环，从而执行后续代码。</p>
</blockquote>
就以调试修改后的 myfork.c 程序（已将其编译为 myfork.exe 可执行文件）为例：
<p class="info-box">
	[root@bogon demo]# gdb myfork.exe -q<br>
	Reading symbols from ~/demo/myfork.exe...done.<br>
	(gdb) r<br>
	Starting program: ~/demo/myfork.exe<br>
	Detaching after fork from child process 5316.&nbsp; &lt;-- 子进程的 ID 号为 5316<br>
	this is parent,pid = 5313&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- 父进程执行完毕<br>
	<br>
	Program exited normally.<br>
	(gdb) attach 5316&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;-- 跳转调试 ID 号为 5316 的子进程<br>
	......<br>
	(gdb) n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- 程序正在运行，所有直接使用 next 命令就可以进行单步调试<br>
	Single stepping until exit from function __nanosleep_nocancel,<br>
	which has no line number information.<br>
	0x00000037ee2acb50 in sleep () from /lib64/libc.so.6<br>
	(gdb) n<br>
	Single stepping until exit from function sleep,<br>
	which has no line number information.<br>
	main () at myfork.c:10<br>
	10&nbsp; while(num==10){<br>
	(gdb) p num=1<br>
	$1 = 1<br>
	(gdb) n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- 跳出循环<br>
	13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("this is child,pid = %d\n",getpid());<br>
	(gdb) c<br>
	Continuing.<br>
	this is child,pid = 5316<br>
	<br>
	Program exited normally.<br>
	(gdb)&nbsp;</p>
<blockquote>
	<p>
		对于子进程 ID 号的获取，除了依靠 GDB 调试器打印出的信息，也可以使用 pidof 命令手动获取。有关 pidof 命令获取进程 ID 好的具体用法，我已经在《<a href="http://c.biancheng.net/view/8166.html" target="_blank">调用GDB的几种方式</a>》一节中做了详细的讲解，这里不再重复赘述。</p>
</blockquote>
<h2>
	GDB显式指定要调试的进程</h2>
前面提到，GDB 调试多进程程序时默认只调试父进程。对于内核版本为 2.5.46 甚至更高的 Linux 发行版系统来说，可以通过修改 follow-fork-mode 或者 detach-on-fork 选项的值来调整这一默认设置。
<h4>
	GDB follow-fork-mode选项</h4>
确切地说，对于使用 fork() 或者 vfork() 函数构建的多进程程序，借助 follow-fork-mode 选项可以设定 GDB 调试父进程还是子进程。该选项的使用语法格式为：<br>
<p class="info-box">
	(gdb) set follow-fork-mode mode</p>
参数 mode 的可选值有 2 个：
<ul>
	<li>
		parent：选项的默认值，表示 GDB 调试器默认只调试父进程；</li>
	<li>
		child：和 parent 完全相反，它使的 GDB 只调试子进程。且当程序中包含多个子进程时，我们可以逐一对它们进行调试。</li>
</ul>
<br>
举个例子：
<p class="info-box">
	(gdb) show follow-fork-mode<br>
	Debugger response to a program call of fork or vfork is "parent".<br>
	(gdb) set follow-fork-mode child&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;-- 调试子进程<br>
	(gdb) r&nbsp;<br>
	Starting program: ~/demo/myfork.exe<br>
	[New process 5376]<br>
	this is parent,pid = 5375&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;-- 父进程执行完成<br>
	<br>
	Program received signal SIGTSTP, Stopped (user).<br>
	[Switching to process 5376]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- 自动进入子进程<br>
	0x00000037ee2accc0 in __nanosleep_nocancel () from /lib64/libc.so.6<br>
	(gdb) n<br>
	Single stepping until exit from function __nanosleep_nocancel,<br>
	which has no line number information.<br>
	0x00000037ee2acb50 in sleep () from /lib64/libc.so.6<br>
	(gdb) n<br>
	Single stepping until exit from function sleep,<br>
	which has no line number information.<br>
	main () at myfork.c:10<br>
	10&nbsp; while(num==10){<br>
	(gdb) p num=1<br>
	$2 = 1<br>
	(gdb) c<br>
	Continuing.<br>
	this is child,pid = 5376</p>
<br>
通过执行如下命令，我们可以轻松了解到当前调试环境中 follow-fork-mode 选项的值：
<p class="info-box">
	(gdb) show follow-fork-mode<br>
	Debugger response to a program call of fork or vfork is "<span style="color: rgb(0, 128, 0);">child</span>".</p>
<h4>
	GDB detach-on-fork选项</h4>
注意，借助 follow-fork-mode 选项，我们只能选择调试子进程还是父进程，且一经选定，调试过程中将无法改变。如果既想调试父进程，又想随时切换并调试某个子进程，就需要借助 detach-on-fork 选项。<br>
<br>
detach-on-fork 选项的语法格式如下：
<p class="info-box">
	(gdb) set detach-on-fork mode</p>
其中，mode 参数的可选值有 2 个：
<ul>
	<li>
		on：默认值，表明 GDB 只调试一个进程，可以是父进程，或者某个子进程；</li>
	<li>
		off：程序中出现的每个进程都会被 GDB 记录，我们可以随时切换到任意一个进程进行调试。</li>
</ul>
<br>
和 detach-on-fork 搭配使用的，还有如表 1 所示的几个命令。<br>
<br>
<table>
	<caption>
		表 1 GDB多进程调试常用命令</caption>
	<tbody>
		<tr>
			<th>
				命令语法格式</th>
			<th>
				功 能</th>
		</tr>
		<tr>
			<td>
				(gdb)show detach-on-fork</td>
			<td>
				查看当前调试环境中 detach-on-fork 选项的值。</td>
		</tr>
		<tr>
			<td>
				(gdb) info inferiors</td>
			<td>
				查看当前调试环境中有多少个进程。其中，进程 id 号前带有 * 号的为当前正在调试的进程。</td>
		</tr>
		<tr>
			<td>
				(gdb) inferiors id</td>
			<td>
				切换到指定 ID 编号的进程对其进行调试。</td>
		</tr>
		<tr>
			<td>
				(gdb) detach inferior id</td>
			<td>
				断开 GDB 与指定 id 编号进程之间的联系，使该进程可以独立运行。不过，该进程仍存在 info inferiors 打印的列表中，其 Describution 列为 &lt;null&gt;，并且借助 run 仍可以重新启用。</td>
		</tr>
		<tr>
			<td>
				(gdb) kill inferior id</td>
			<td>
				断开 GDB 与指定 id 编号进程之间的联系，并中断该进程的执行。不过，该进程仍存在 info inferiors 打印的列表中，其 Describution 列为 &lt;null&gt;，并且借助 run 仍可以重新启用。</td>
		</tr>
		<tr>
			<td>
				remove-inferior id</td>
			<td>
				彻底删除指令 id 编号的进程（从 info inferiors 打印的列表中消除），不过在执行此操作之前，需先使用 detach inferior id 或者 kill inferior id 命令将该进程与 GDB 分离，同时确认其不是当前进程。</td>
		</tr>
	</tbody>
</table>
<blockquote>
	<p>
		除表 1 罗列的这几个命令，GDB 调试其提供有其它的一些命令，由于不常用，这里不再罗列，读者可前往<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Inferiors-Connections-and-Programs.html#Inferiors-Connections-and-Programs" target="_blank"> GDB官网</a>自行查看。</p>
</blockquote>
这里仍以调试 myfork.c 程序为例，不过为了让读者清楚地感受 detach-on-fork 选项的功能，这里需要对 else 语句块的代码进行如下修改：
<div class="snippet-container" style="undefined;"><div class="sh_bright snippet-wrap"><div class="snippet-menu sh_sourceCode" style="display:none;"><pre><a class="snippet-copy sh_url" href="http://c.biancheng.net/view/vip_8517.html#" style="display: none;">复制</a><a class="snippet-text sh_url" href="http://c.biancheng.net/view/vip_8517.html#">纯文本</a><a class="snippet-window sh_url" href="http://c.biancheng.net/view/vip_8517.html#">复制</a></pre></div><pre class="cpp sh_cpp snippet-formatted sh_sourceCode"><ol class="snippet-num"><li><span class="sh_keyword">else</span></li><li><span class="sh_cbracket">{</span></li><li>    <span class="sh_type">int</span> mnum<span class="sh_symbol">=</span><span class="sh_number">5</span><span class="sh_symbol">;</span></li><li>    <span class="sh_keyword">while</span><span class="sh_symbol">(</span>mnum<span class="sh_symbol">==</span><span class="sh_number">5</span><span class="sh_symbol">)</span><span class="sh_cbracket">{</span></li><li>        <span class="sh_function">sleep</span><span class="sh_symbol">(</span><span class="sh_number">1</span><span class="sh_symbol">);</span></li><li>    <span class="sh_cbracket">}</span></li><li>    <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"this is parent,pid = %d</span><span class="sh_specialchar">\n</span><span class="sh_string">"</span><span class="sh_symbol">,</span><span class="sh_function">getpid</span><span class="sh_symbol">());</span></li><li><span class="sh_cbracket">}</span></li></ol></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;">else
{
    int mnum=5;
    while(mnum==5){
        sleep(1);
    }
    printf("this is parent,pid = %d\n",getpid());
}</pre></div></div>
<blockquote>
	<p>
		也就是说，myfork.c 程序中，父进程和子进程中各拥有一个死循环。</p>
</blockquote>
在此基础上，进行如下调试：&nbsp;
<p class="info-box">
	(gdb) <span style="color:#008000;">set detach-on-fork off&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- 令 GDB 可调试多个进程</span><br>
	(gdb) b 6<br>
	Breakpoint 1 at 0x11b5: file myfork.c, line 6.<br>
	(gdb) r<br>
	Starting program: ~/demo/myfork.exe<br>
	<br>
	Breakpoint 1, main () at myfork.c:6<br>
	6&nbsp;&nbsp;&nbsp;&nbsp; pid_t pid = fork();<br>
	(gdb) n<br>
	[New inferior 2 (process 5163)]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- 新增一个子进程，ID 号为 5163<br>
	Reading symbols from ~/demo/myfork.exe...<br>
	Reading symbols from /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so...<br>
	7&nbsp;&nbsp;&nbsp;&nbsp; if(pid == 0)<br>
	(gdb) n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;-- 由于 GDB 默认调试父进程，因此进入 else 语句<br>
	17&nbsp;&nbsp;&nbsp;&nbsp; int mnum=5;<br>
	(gdb) info inferiors&nbsp; &nbsp; &nbsp;&lt;-- 查看当前调试环境中的进程数，当前有 2 个进程，1 号进程为当前正在调试的进程<br>
	&nbsp; Num&nbsp; Description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Executable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
	* 1&nbsp;&nbsp;&nbsp; process 5159&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~/demo/myfork.exe<br>
	&nbsp; 2&nbsp;&nbsp;&nbsp; process 5163&nbsp; &nbsp; &nbsp; &nbsp;~/demo/myfork.exe<br>
	(gdb) inferior 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- 进入 id 号为 2 的子进程<br>
	[Switching to inferior 2 [process 5163] (~/demo/myfork.exe)]<br>
	[Switching to thread 2.1 (process 5163)]<br>
	(gdb) n<br>
	53 in ../sysdeps/unix/sysv/linux/arch-fork.h<br>
	(gdb) n<br>
	__libc_fork () at ../sysdeps/nptl/fork.c:78<br>
	78 ../sysdeps/nptl/fork.c: No such file or directory.<br>
	(gdb) n<br>
	......&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- 执行多个 next 命令<br>
	(gdb) n<br>
	main () at myfork.c:7&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;-- 正式单步调试子进程&nbsp;&nbsp;<br>
	7&nbsp;&nbsp;&nbsp;&nbsp; if(pid == 0)<br>
	(gdb) n<br>
	9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int num =10;<br>
	(gdb)</p>
可以看到，通过设置 detach-on-fork 选项值为 off，再配合使用 info inferiors 等命令，即可随意切换到当前环境中的各个进程，并对它们进行调试。
<blockquote>
	<p>
		感兴趣的读者，可自行以默认模式（即 detach-on-fork 值为 on）调试该程序，对比它们之间的区别。</p>
</blockquote>
</div>
			<div id="arc-append">
	<p>关注微信公众号「站长严长生」，在手机上阅读所有教程，随时随地都能学习。本公众号由<a class="col-link" href="http://c.biancheng.net/view/8092.html" target="_blank" rel="nofollow">C语言中文网站长</a>运营，每日更新，坚持原创，敢说真话，凡事有态度。</p>
	<p style="margin-top:12px; text-align:center;">
		<img width="180" src="./20GDB调试多进程程序_files/qrcode_weixueyuan_original.png" alt="魏雪原二维码"><br>
		<span class="col-green">微信扫描二维码关注公众号</span>
	</p>
</div>
<!-- <p>关注微信公众号「魏雪原」，跟着<a class="col-link" href="/view/8092.html" target="_blank">站长</a>一起学习，拒绝躺平，跳出内卷，用知识完成阶级跃升：</p>
	<ul>
		<li>每日更新，坚持原创，敢说真话，凡事有态度。</li>
		<li>编程+求职+创业+营销，既有硬知识，也有软技能。</li>
		<li>手机端阅读教程，随时随地都能学习。</li>
		<li>即将绑定网站部分功能，包括注册登录、找回密码、获取下载链接等。</li>
	</ul> -->
			<div class="pre-next-page clearfix">
                    <span class="pre left"><span class="icon">&lt;</span> <span class="text-brief text-brief-pre">上一页</span><a href="http://c.biancheng.net/view/vip_8516.html">GDB如何在后台执行调试命令？</a></span>
                    <span class="next right"><a href="http://c.biancheng.net/view/vip_8518.html">GDB如何进行反向调试？</a><span class="text-brief text-brief-next">下一页</span> <span class="icon">&gt;</span></span>
                </div>
			<div id="ad-arc-bottom"></div>

<!-- <div id="ad-bottom-weixin" class="clearfix">
	<div class="left" style="width: 535px;">
		<p><span class="col-red">编程帮</span>，一个分享编程知识的公众号。跟着<a class="col-link" href="/cpp/about/author/" target="_blank">站长</a>一起学习，每天都有进步。</p>
		<p>通俗易懂，深入浅出，一篇文章只讲一个知识点。</p>
		<p>文章不深奥，不需要钻研，在公交、在地铁、在厕所都可以阅读，随时随地涨姿势。</p>
		<p>文章不涉及代码，不烧脑细胞，人人都可以学习。</p>
		<p>当你决定关注「编程帮」，你已然超越了90%的程序员！</p>
	</div>
	<div class="right" style="width: 150px;">
		<img width="150" src="/templets/new/images/erweima_biancheng.gif?v=1.6.72" alt="编程帮二维码" /><br />
		<span class="col-green">微信扫描二维码关注</span>
	</div>
</div> -->

<div id="nice-arcs" class="box-bottom">
	<h4>优秀文章</h4>
	<ul class="clearfix">
<li><a href="http://c.biancheng.net/view/3373.html" title="十字链表法，十字链表压缩存储稀疏矩阵详解">十字链表法，十字链表压缩存储稀疏矩阵详解</a></li>
<li><a href="http://c.biancheng.net/view/4770.html" title="Python close()函数：关闭文件">Python close()函数：关闭文件</a></li>
<li><a href="http://c.biancheng.net/view/5768.html" title="JS泛型函数">JS泛型函数</a></li>
<li><a href="http://c.biancheng.net/view/5932.html" title="JSONP跨域请求入门教程（附带实例）">JSONP跨域请求入门教程（附带实例）</a></li>
<li><a href="http://c.biancheng.net/view/6075.html" title="AJAX发送和接收Blob对象（案例实战）">AJAX发送和接收Blob对象（案例实战）</a></li>
<li><a href="http://c.biancheng.net/view/6572.html" title="Python操作MongoDB数据库（简明版）">Python操作MongoDB数据库（简明版）</a></li>
<li><a href="http://c.biancheng.net/view/7393.html" title="vector&lt;bool&gt;不是存储bool类型元素的vector容器！">vector&lt;bool&gt;不是存储bool类型元素的vector容器！</a></li>
<li><a href="http://c.biancheng.net/view/7411.html" title="C++ map（STL map）operator[]和insert()效率对比（深度剖析）">C++ map（STL map）operator[]和insert()效率对比（深度剖析）</a></li>
<li><a href="http://c.biancheng.net/view/8132.html" title="JS代码如何嵌入到网页中">JS代码如何嵌入到网页中</a></li>
<li><a href="http://c.biancheng.net/pandas/plot.html" title="Python Pandas绘图教程（详解版）">Python Pandas绘图教程（详解版）</a></li>
</ul>
</div>
		</div>
		
	</div>
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 8517;
window.arcId = "2d83HbsP+B1refWbQmcm2GqtOnCy3anu4zRGbzRi7/YFRJ2RCMGa0wPWuRc";
window.typeidChain = "154";
</script>
<div id="footer" class="clearfix">
	<div class="info left">
	<p>精美而实用的网站，分享优质编程教程，帮助有志青年。千锤百炼，只为大作；精益求精，处处斟酌；这种教程，看一眼就倾心。</p>
	<p>
		<a href="http://c.biancheng.net/view/8066.html" target="_blank" rel="nofollow">关于网站</a> <span>|</span>
		<a href="http://c.biancheng.net/view/8092.html" target="_blank" rel="nofollow">关于站长</a> <span>|</span>
		<a href="http://c.biancheng.net/view/8097.html" target="_blank" rel="nofollow">如何完成一部教程</a> <span>|</span>
		<a href="http://c.biancheng.net/view/8093.html" target="_blank" rel="nofollow">联系我们</a> <span>|</span>
		<a href="http://c.biancheng.net/sitemap/" target="_blank" rel="nofollow">网站地图</a>
	</p>
	<p>Copyright ©2012-2021 biancheng.net, <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="nofollow" style="color:#666;">陕ICP备15000209号</a></p>
	</div>
	<img class="right" src="./20GDB调试多进程程序_files/logo_bottom.gif" alt="底部Logo">
	<span id="return-top"><b>↑</b></span>
</div>

<script type="text/javascript">
window.siteId = 4;
window.cmsTemplets = "/templets/new";
window.cmsTempletsVer = "1.6.72";
</script>

<script src="./20GDB调试多进程程序_files/jquery1.12.4.min.js.下载"></script>
<script src="./20GDB调试多进程程序_files/common.js.下载"></script>
<span style="display:none;"><script src="./20GDB调试多进程程序_files/z_stat.php" type="text/javascript" defer="defer" async="async"></script></span>

</body></html>